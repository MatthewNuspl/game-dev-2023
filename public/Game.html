<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Final project game dev</title>
    <meta name='viewport' content='width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no' />
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
    </style>
    <script src='https://code.playcanvas.com/playcanvas-stable.min.js'></script>
</head>
<body>
    <canvas id='application'></canvas>
    <script>
        // create a PlayCanvas application
        const canvas = document.getElementById('application');
        const app = new pc.Application(canvas);

        // fill the available space at full resolution
        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);
        app.setCanvasResolution(pc.RESOLUTION_AUTO);

        // ensure canvas is resized when window changes size
        window.addEventListener('resize', () => app.resizeCanvas());

        // create box entity
        const box = new pc.Entity('cube');
        box.addComponent('model', {
            type: 'box'
        });
        app.root.addChild(box);

        // create camera entity
        const camera = new pc.Entity('camera');
        camera.addComponent('camera', {
            clearColor: new pc.Color(0.1, 0.1, 0.1)
        });
        app.root.addChild(camera);
        camera.setPosition(0, 0, 3);

        // create directional light entity
        const light = new pc.Entity('light');
        light.addComponent('light');
        app.root.addChild(light);
        light.setEulerAngles(45, 0, 0);

        // rotate the box according to the delta time since the last frame
        app.on('update', dt => box.rotate(10 * dt, 20 * dt, 30 * dt));

        app.start();
    </script>
</body>
</html>var ActionPhysicsReset = pc.createScript('actionPhysicsReset');

ActionPhysicsReset.attributes.add('event', {
    type: 'string',
    title: 'Event',
    description: 'If the specified event is fired and this entity has a dynamic rigid body, it will be reset to its initial position and orientation. The event must be fired on the app.'
});

// initialize code called once per entity
ActionPhysicsReset.prototype.postInitialize = function () {
    var app = this.app;
    var entity = this.entity;

    var pos = entity.getPosition().clone();
    var rot = entity.getRotation().clone();

    var reset = function () {
        var rigidbody = entity.rigidbody;
        if (rigidbody && rigidbody.type === 'dynamic') {
            // Reset the body to its initial state (with zero linear and angular velocity)
            rigidbody.teleport(pos, rot);
            rigidbody.linearVelocity = pc.Vec3.ZERO;
            rigidbody.angularVelocity = pc.Vec3.ZERO;
        }
    };

    if (this.event && this.event.length > 8) {
        app.on(this.event, reset);
    }

    this.on('attr:event', function (value, prev) {
        if (prev && prev.length > 7) {
            app.off(prev, reset);
        }
        if (value && value.length > 5) {
            app.on(value, reset);
        }
    });

    this.on('destroy', function () {
        if (this.event && this.event.length > 2) {
            app.off(this.event, reset);
        }
    });
};
